<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Document</title>
	<style>
		p {
			margin: 1rem;
		}
	</style>
	<script>

		const graph = [
			{'name': 'A', 'parent': []        , 'time':  1 },
			{'name': 'B', 'parent': ['A']     , 'time':  2 },
			{'name': 'C', 'parent': ['B']     , 'time':  3 },
			{'name': 'D', 'parent': ['C']     , 'time':  4 },
			{'name': 'E', 'parent': ['C']     , 'time':  5 },
			{'name': 'F', 'parent': ['D']     , 'time':  6 },
			{'name': 'G', 'parent': ['E']     , 'time':  7 },
			{'name': 'H', 'parent': ['F']     , 'time':  8 },
			{'name': 'I', 'parent': ['G']     , 'time':  9 },
			{'name': 'J', 'parent': ['G']     , 'time': 10 },
			{'name': 'K', 'parent': ['G']     , 'time': 11 },
			{'name': 'L', 'parent': ['H']     , 'time': 12 },
			{'name': 'M', 'parent': ['H']     , 'time': 13 },
			{'name': 'N', 'parent': ['J']     , 'time': 14 },
			{'name': 'O', 'parent': ['N']     , 'time': 15 },
			{'name': 'P', 'parent': ['I', 'M'], 'time': 16 },
			{'name': 'Q', 'parent': ['L', 'O'], 'time': 17 },
			{'name': 'R', 'parent': ['P', 'Q'], 'time': 18 },
			{'name': 'S', 'parent': ['R', 'K'], 'time': 19 },
			{'name': 'T', 'parent': ['S']     , 'time': 20 },
			{'name': 'U', 'parent': ['T']     , 'time': 21 }
		];

		let C = graph.map((g) => ({
			'name': g.name,
			'timestamp': g.time,
			'i': undefined,
			'j': undefined,
			'parents': g.parent,
			'children': [],
			'merge': [],
			'branch': [],
			'explored': false
		}));
		C.forEach((c) => {
			parent = c.parents;
			c.parents = C.filter((d) => parent.includes(d.name));
		});
		C.forEach((c) => {
			c.children = C.filter((d) => d.parents.includes(c));
			c.branch = c.children.filter((d) => d.parents[0] == c);
			c.merge = c.children.filter((d) => d.parents[0] != c);
		});
		C.sort((c, d) => (c.timestamp < d.timestamp) ? 1 : -1);

		{
			function dfs(c) {
				if (!c.explored) {
					c.explored = true;
					c.children.forEach((d) => dfs(d));
					c.i = i;
					i += 1;
				}
			}
			let i = 0;
			C.forEach((c) => dfs(c));
		}

		C.sort((c, d) => (c.i > d.i) ? 1 : -1);

		function curved() {
			let B = [];
			C.forEach((c) => {
				D_ = [];
				if (c.branch.length > 0) {
					d = c.branch[0];
					D_.push(d);
					B[B.findIndex((e) => e == d)] = c;
				} else {
					B.push(c);
				}
				nD_ = c.branch.filter((d) => !D_.includes(d));
				nD_.forEach((d_) => {
					let index = B.findIndex((e) => e == d_);
					if (index > -1)
						B.splice(index, 1);
				});
				c.j = B.findIndex((d) => d == c);
			});
		}

		function straight() {
			let F = [];

			function J(c) {
				if (c.merge.length == 0)
					return [];
				let Jc = [];
				let di = Math.min.apply(Math, c.merge.map((m) => m.i));
				for (let j = 0; j < F[0].length; ++j)
					for (let i = c.i - 1; i > di; --i)
						if (F[i][j] != null) {
							Jc.push(j);
							break;
						}
				return Jc;
			}

			let B = [];
			C.forEach((c) => {
				let  Jc = J(c);
				let nJc = c.branch.filter((d) => !Jc.includes(d.j));
				let  D_ = [];
				if (nJc.length > 0) {
					d = nJc[0];
					D_.push(d);
					B[B.findIndex((e) => e == d)] = c;
				} else {
					B.push(c);
				}
				let nD_ = c.branch.filter((d) => !D_.includes(d));
				nD_.forEach((d_) => B[d_.j] = null);
				c.j = B.findIndex((d) => d == c);

				F.push(B.map((b) => (b == null) ? null : b.name));
				F_col = Math.max.apply(Math, F.map((f) => f.length));
				F.forEach((f) => {
					while (f.length < F_col)
						f.push(null);
				});
			});
		}


		// curved();
		straight();

		C.forEach((c) => {
			let tmp = c.i;
			c.i = c.j;
			c.j = tmp;
		});

		const row = Math.max.apply(Math, C.map((c) => c.i)) + 1;
		const col = Math.max.apply(Math, C.map((c) => c.j)) + 1;

		C.forEach((c) => {c.j = col - c.j - 1; c.i = row - c.i - 1;});

	</script>
</head>
<body>
	<div id="show graph"></div>

	<script>

		let show_graph = document.getElementById('show graph');
		show_graph.innerHTML = '';

		show_graph.style['display'] = 'grid';
		show_graph.style['grid-template-rows'] = `repeat(${row}, 1fr)`;
		show_graph.style['grid-template-columns'] = `repeat(${col}, 1fr)`;

		C.forEach((c) => {
			let p = document.createElement('p');
			let t = document.createTextNode(c.name);
			p.appendChild(t);
			p.style['text-align'] = 'center';
			p.style['grid-row-start'] = c.i + 1;
			p.style['grid-row-end'] = c.i + 2;
			p.style['grid-column-start'] = c.j + 1;
			p.style['grid-column-end'] = c.j + 2;
			p.style['background-color'] = 'cyan';
			show_graph.appendChild(p);
		});

		C.forEach((c) => {c.children.forEach((b) => {
			const p = {
				'l': Math.min(c.j, b.j) + 1,
				'r': Math.max(c.j, b.j) + 2,
				't': Math.min(c.i, b.i) + 1,
				'b': Math.max(c.i, b.i) + 2
			};
			let d = document.createElement('div');
			d.style['grid-row-start'] = p.t;
			d.style['grid-row-end'] = p.b;
			d.style['grid-column-start'] = p.l;
			d.style['grid-column-end'] = p.r;
			d.style['z-index'] = -10;
			show_graph.appendChild(d);
			const m = {
				'w': p.r - p.l,
				'h': p.b - p.t
			};
			const a = (() => {
				const r = d.getBoundingClientRect();
				const w = r.width / m.w;
				const h = r.height / m.h;
				if (w < h) return {'w': 1, 'h': h / w};
				if (w > h) return {'w': w / h, 'h': 1};
				return {'w': 1, 'h': 1};
			})();
			let s = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
			s.style['width'] = 0;
			s.style['height'] = 0;
			s.style['min-width'] = '100%';
			s.style['min-height'] = '100%';
			s.setAttribute('viewBox', `0 0 ${m.w * a.w} ${m.h * a.h}`);
			let l = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
			l.setAttribute('fill', 'none');
			l.setAttribute('stroke', 'black');
			l.setAttribute('stroke-width', '0.05');
			if (c.i == b.i)
				l.setAttribute('points', `${0.5 * a.w} ${0.5 * a.h} ${(m.w - 0.5) * a.w} ${0.5 * a.h}`);
			else
				if (c.branch.includes(b))
					if (c.i < b.i)
						l.setAttribute('points', `${0.5 * a.w} ${0.5 * a.h} ${0.5 * a.w} ${(m.h - 0.5) * a.h} ${(m.w - 0.5) * a.w} ${(m.h - 0.5) * a.h}`);
					else
						l.setAttribute('points', `${0.5 * a.w} ${(m.h - 0.5) * a.h} ${0.5 * a.w} ${0.5 * a.h} ${(m.w - 0.5) * a.w} ${0.5 * a.h}`);
				else
					if (c.i < b.i)
						l.setAttribute('points', `${0.5 * a.w} ${0.5 * a.h} ${(m.w - 0.5) * a.h} ${0.5 * a.h} ${(m.w - 0.5) * a.h} ${(m.h - 0.5) * a.h}`);
					else
						l.setAttribute('points', `${0.5 * a.w} ${(m.h - 0.5) * a.h} ${(m.w - 0.5) * a.w} ${(m.h - 0.5) * a.h} ${(m.w - 0.5) * a.w} ${0.5 * a.h}`);
			s.appendChild(l);
			d.appendChild(s);
		})});

	</script>
</body>
</html>
